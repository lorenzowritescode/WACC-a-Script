package antlr;

import java.util.ArrayList;

import org.antlr.v4.runtime.tree.ParseTree;

import symboltable.SymbolTable;
import tree.ProgNode;
import tree.WACCTree;
import tree.expr.AndExpr;
import tree.expr.ArithExpr;
import tree.expr.BoolLeaf;
import tree.expr.CharLeaf;
import tree.expr.ExprNode;
import tree.expr.EqNotExpr;
import tree.expr.GrtLessExpr;
import tree.expr.IntLeaf;
import tree.expr.MultDivExpr;
import tree.expr.OrExpr;
import tree.expr.StringLeaf;
import tree.func.FuncDecNode;
import tree.func.ParamListNode;
import tree.func.ParamNode;
import tree.stat.IfStatNode;
import tree.stat.ReturnStatNode;
import tree.stat.SeqStatNode;
import tree.stat.StatNode;
import tree.stat.VarDecNode;
import tree.stat.WhileStatNode;
import tree.type.WACCType;
import antlr.WACCParser.And_exprContext;
import antlr.WACCParser.Arithmetic_exprContext;
import antlr.WACCParser.Binary_operContext;
import antlr.WACCParser.Array_typeContext;
import antlr.WACCParser.Assign_lhsContext;
import antlr.WACCParser.Assign_rhsContext;
import antlr.WACCParser.Bool_literContext;
import antlr.WACCParser.Char_literContext;
import antlr.WACCParser.Equals_not_exprContext;
import antlr.WACCParser.Exit_statContext;
import antlr.WACCParser.ExprContext;
import antlr.WACCParser.Free_statContext;
import antlr.WACCParser.FuncContext;
import antlr.WACCParser.Greater_less_exprContext;
import antlr.WACCParser.If_statContext;
import antlr.WACCParser.Int_literContext;
import antlr.WACCParser.Multdiv_exprContext;
import antlr.WACCParser.Pair_typeContext;
import antlr.WACCParser.Or_exprContext;
import antlr.WACCParser.ParamContext;
import antlr.WACCParser.Param_listContext;
import antlr.WACCParser.ProgContext;
import antlr.WACCParser.Return_statContext;
import antlr.WACCParser.Sequential_statContext;
import antlr.WACCParser.Single_exprContext;
import antlr.WACCParser.Str_literContext;
import antlr.WACCParser.Variable_declarationContext;
import antlr.WACCParser.While_statContext;
import assignments.AssignRhsNode;

public class SemanticChecker extends WACCParserBaseVisitor<WACCTree>{

	private ParseTree parseTree;
	private SymbolTable currentSymbolTable;

	public SemanticChecker(ParseTree t) {
		this.parseTree = t;
		this.currentSymbolTable = new SymbolTable();
	}

	public void init() {
		parseTree.accept(this);
	}

	@Override
	public WACCTree visitFunc(FuncContext ctx) {
		// Visit the param list and get the ParamListNode
		ParamListNode params = (ParamListNode) visit(ctx.param_list());
		
		// Create an inner scope Symbol Table for the function body.
		currentSymbolTable = new SymbolTable(currentSymbolTable);
		
		// Create the functionBody node
		StatNode funcBody = (StatNode) visit(ctx.stat());
		
		// restore the scope to the original table
		currentSymbolTable = currentSymbolTable.getParent();
		
		// Pull out type and function name
		WACCType returnType = WACCType.evalType(ctx.type());
		String funcName = ctx.ident().getText();
		
		// Create new functionNode and check it
		FuncDecNode funcNode = new FuncDecNode(returnType, funcName, params, funcBody);
		funcNode.check(currentSymbolTable, ctx);
		
		return funcNode;
	}

	@Override
	public WACCTree visitReturn_stat(Return_statContext ctx) {
		WACCTree exprType = visit(ctx.expr());
		exprType.check(currentSymbolTable, null);
		
		ReturnStatNode rst = new ReturnStatNode(exprType);
		rst.check(currentSymbolTable, null);
		return rst;
	}

	@Override
	public WACCTree visitSequential_stat(Sequential_statContext ctx) {
		StatNode lhs = (StatNode) visit(ctx.stat(0));
		lhs.check(currentSymbolTable, null);
		StatNode rhs = (StatNode) visit(ctx.stat(1));
		rhs.check(currentSymbolTable, null);
		return new SeqStatNode(lhs, rhs);
	}

	@Override
	public WACCTree visitProg(ProgContext ctx) {
		// First we visit all functions and register a stub of its return type
		for (FuncContext fctx : ctx.func()){
			registerFunction(fctx);
		}
		
		ArrayList<FuncDecNode> functions = new ArrayList<>();
		// We visit all the functions and create full nodes
		for (FuncContext fctx : ctx.func()){
			FuncDecNode fdec = (FuncDecNode) visit(fctx);
			fdec.check(currentSymbolTable, null);
			functions.add(fdec);
		}
		
		// Then we visit the statement
		StatNode progBody = (StatNode) visit(ctx.stat());
		progBody.check(currentSymbolTable, null);
		
		// Finally, we return the program node
		return new ProgNode(functions, progBody);
	}

	/**
	 * registerFunction adds a stub of the function into the currentSymbolTable without recursing into the function body.
	 * This is to support nested function calls, where a function body might call a not yet defined function.
	 * @param fctx
	 * 		The FuncContext generated by the Parser
	 */
	private void registerFunction(FuncContext fctx) {
		String funcName = fctx.ident().getText();
		WACCType returnType = WACCType.evalType(fctx.type());
		FuncDecNode funcStub = new FuncDecNode(returnType, funcName);
		currentSymbolTable.add(funcName, funcStub);
	}

	@Override
	public WACCTree visitVariable_declaration(Variable_declarationContext ctx) {
		AssignRhsNode rhsTree = (AssignRhsNode) visit(ctx.assign_rhs());
		WACCType varType = WACCType.evalType(ctx.type());
		String ident = ctx.ident().getText();
		VarDecNode vcd = new VarDecNode(varType, ident, rhsTree);
		vcd.check(currentSymbolTable, null);
		return vcd;
	}


	@Override
	public WACCTree visitChar_liter(Char_literContext ctx) {
		CharLeaf charleaf = new CharLeaf(ctx.getText());
		charleaf.check(currentSymbolTable, null);
		return charleaf;
	}

	@Override
	public WACCTree visitInt_liter(Int_literContext ctx) {
		int value = Integer.parseInt(ctx.getText());
		IntLeaf intLeaf = new IntLeaf(value);
		intLeaf.check(currentSymbolTable, ctx);
		return intLeaf;
	}

	@Override
	public WACCTree visitBool_liter(Bool_literContext ctx) {
		BoolLeaf boolLeaf = new BoolLeaf(ctx.getText());
		boolLeaf.check(currentSymbolTable, ctx);
		return boolLeaf;
	}

	@Override
	public WACCTree visitStr_liter(Str_literContext ctx) {
		StringLeaf strLeaf = new StringLeaf(ctx.getText());
		strLeaf.check(currentSymbolTable, ctx);
		return strLeaf;
	}

	@Override
	public WACCTree visitParam(ParamContext ctx) {
		WACCType paramType = WACCType.evalType(ctx.type());
		String ident = ctx.ident().getText();
		ParamNode paramNode = new ParamNode(paramType, ident);
		paramNode.check(currentSymbolTable, ctx);
		return paramNode;
	}

	@Override
	public WACCTree visitParam_list(Param_listContext ctx) {
		ParamListNode params = new ParamListNode();
		for (ParamContext p : ctx.param()){
			ParamNode pn = (ParamNode) visit(p);
			params.add(pn);
		}
		params.check(currentSymbolTable, ctx);
		return params;
	}

	@Override
	public WACCTree visitWhile_stat(While_statContext ctx) {
		ExprNode loopCond = (ExprNode) visit(ctx.expr());
		WhileStatNode whileStat = new WhileStatNode(loopCond);
		whileStat.check(currentSymbolTable, ctx);
		return whileStat;
	}

	@Override
	public WACCTree visitIf_stat(If_statContext ctx) {
		ExprNode ifCond = (ExprNode) visit(ctx.expr());
		IfStatNode ifStat = new IfStatNode(ifCond);
		ifStat.check(currentSymbolTable, ctx);
		return ifStat;
	}

	@Override
	public WACCTree visitAnd_expr(And_exprContext ctx) {
		ExprNode lhsExpr = (ExprNode) visit(ctx.getChild(0));
		ExprNode rhsExpr = (ExprNode) visit(ctx.getChild(1));
		AndExpr andExpr = new AndExpr(lhsExpr, rhsExpr);
		andExpr.check(currentSymbolTable, ctx);
		return andExpr;
	}

	@Override
	public WACCTree visitOr_expr(Or_exprContext ctx) {
		ExprNode lhsExpr = (ExprNode) visit(ctx.getChild(0));
		ExprNode rhsExpr = (ExprNode) visit(ctx.getChild(1));
		OrExpr orExpr = new OrExpr(lhsExpr, rhsExpr);
		orExpr.check(currentSymbolTable, ctx);
		return orExpr;
	}

	@Override
	public WACCTree visitGreater_less_expr(Greater_less_exprContext ctx) {
		ExprNode lhsExpr = (ExprNode) visit(ctx.getChild(0));
		ExprNode rhsExpr = (ExprNode) visit(ctx.getChild(1));
		GrtLessExpr grtLessExpr = new GrtLessExpr(lhsExpr, rhsExpr);
		grtLessExpr.check(currentSymbolTable, ctx);
		return grtLessExpr;
	}

	@Override
	public WACCTree visitEquals_not_expr(Equals_not_exprContext ctx) {
		ExprNode lhsExpr = (ExprNode) visit(ctx.getChild(0));
		ExprNode rhsExpr = (ExprNode) visit(ctx.getChild(1));
		EqNotExpr eqNotExpr = new EqNotExpr(lhsExpr, rhsExpr);
		eqNotExpr.check(currentSymbolTable, ctx);
		return eqNotExpr;
	}

	@Override
	public WACCTree visitMultdiv_expr(Multdiv_exprContext ctx) {
		ExprNode lhsExpr = (ExprNode) visit(ctx.getChild(0));
		ExprNode rhsExpr = (ExprNode) visit(ctx.getChild(1));
		MultDivExpr multDivExpr = new MultDivExpr(lhsExpr, rhsExpr);
		multDivExpr.check(currentSymbolTable, ctx);
		return multDivExpr;
	}

	@Override
	public WACCTree visitArithmetic_expr(Arithmetic_exprContext ctx) {
		ExprNode lhsExpr = (ExprNode) visit(ctx.getChild(0));
		ExprNode rhsExpr = (ExprNode) visit(ctx.getChild(1));
		ArithExpr arithExpr = new ArithExpr(lhsExpr, rhsExpr);
		arithExpr.check(currentSymbolTable, ctx);
		return arithExpr;
	}
	
}
